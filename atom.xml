<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zippera's blog]]></title>
  <subtitle><![CDATA[Walk steps step by step]]></subtitle>
  <link href="http://zipperary.com/atom.xml" rel="self"/>
  <link href="http://zipperary.com"/>
  <updated>2014-05-12T12:13:14.266Z</updated>
  <id>http://zipperary.com/</id>
  <author>
    <name><![CDATA[zippera]]></name>
    <email><![CDATA[sovey198@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[論開會]]></title>
    <link href="http://zipperary.com/2014/05/12/on-meeting/"/>
    <id>http://zipperary.com/2014/05/12/on-meeting/</id>
    <published>2014-05-12T10:43:48.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Few meetings are exciting and effcient, some ordinary, many boring, a few fucking unbearable.</p>
</blockquote>
<p>從小到大，開過不少會了。人多的地方就會有組織，有組織的地方就需要開會討論一些事情。雖然從沒做過會議主持，但作為與會者，對與開會的感受卻並不淺。回憶起來，幾乎沒有參加過上述那第一類會議，基本都是後面那些，而且極貼合這些量詞。</p>
<p>就不抱怨各種奇葩的會議了，說說我希望的會議是什麼樣的吧，萬一哪天我也做一次主持人呢。</p>
<p>正式開會前，可以先聚集小組成員，開一個預會，任務是交待一下正式會議的綱要，要討論的問題，並請相關的小組成員在開會之前的這段時間內，對於相關的問題或議事進行 think through 或 瞭解調查，並把疑問和需要在會上討論的事情記錄下來。當然，也可以通過電話、短信、電郵等方式通知。最重要的是讓大家知道大概的會議議程，以提前做好準備，免得到時候打醬油。</p>
<a id="more"></a>

<p>要開會了，一定要做好死規定，到點即開會，一般不等待遲到的人。</p>
<p>開會時，老闆或者主持人要把開會的目的說一下，把議程再重申一下，然後依次發言。發言過程中其他人最好不要打擾或插畫，有什麼事情可以先記錄下來；發言者結束後，花一段與其他人交流。發言時，發言者一定要力圖把事情講清楚，這樣發言後的交流階段，不會成為一個再講解的過程，而是進行一個有「信息增益」的交流。其他人也要秉持認真的態度，真正圍繞議題進行討論，一定不要囉嗦、講廢話。</p>
<p>特別要注意的是，與會者一定是在圍繞共同話題做交流的。如果開會時用很多時間專門針對某一個人的某一個比較私人的話題，那麽其他與此話題無關的人的時間就被浪費了，對他們來說，很多時候這都是 fucking unbearable。</p>
<p>開會不是通知，所以民主特別重要。一定不要成為老闆、主持人對與會者的單向信息傳遞，雙方要彼此尊重，給對方發言的機會，與會者也不要只做聽客看客，要參與、要反饋、要質問。</p>
<p>會議最好確定一個大概的持續時間，否則很有可能會變得又臭又長。</p>
<p>會議結束前，要大略梳理一下這次會議的內容，有什麼新的見解、收穫，並做好下一階段的佈置。佈置任務時，也不能採取命令式的，誰誰誰要在兩天之內完成啥啥，要詢問一下對方能不能做到，有什麼困難，有什麽建議，商量出一個可行計劃。當然，也不能語焉不詳，簡單說一句「去做啥啥吧」，deadline 是很重要的。還有一個非常重要的事情：任務一定要明確。布置任務的人未必傳達的準確到位，對方一定要以認真的態度，有不懂的地方即時詢問確認。</p>
<p>上面是我的一些想法，可現實中的會議大多又臭又長，作為與會者，很多時候是無奈的，只能忍受。這時候得想點辦法度過那些 unbearable 的時光了：</p>
<ul>
<li>畫畫，練字</li>
<li>背快捷鍵，複習筆記，背單詞</li>
<li>走私，思考人生</li>
<li>做計劃</li>
</ul>
<p>哎，我點子少，歡迎補充！</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[阿里数据挖掘]]></title>
    <link href="http://zipperary.com/2014/05/08/ali-data-mining/"/>
    <id>http://zipperary.com/2014/05/08/ali-data-mining/</id>
    <published>2014-05-08T08:10:29.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间阿里巴巴组织了一个大数据的竞赛，全国高校积极响应，报名者、参与者、提交者众多，最好成绩也一直在刷新当中。初赛选出 Top500 进入复赛，其他人就炮灰了。</p>
<p>虽然是搞图像的，但念在未来图像不太好就业，而大数据是现在及未来的热门，正巧在修习一门《数据挖掘》课程，就把阿里这个题目作为大作业的题目了。</p>
<h3 id="题目介绍">题目介绍</h3>
<p>题目大意是这样的：</p>
<blockquote>
<p>给定 4.15-7.15 这四个月的用户数据作为训练数据，大概18万条。然后预测下一个月哪些用户会购买哪些品牌。数据提交到阿里的竞赛平台，阿里会给出准确率、召回率和 F1值。</p>
</blockquote>
<p>数据的说明如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eg6xzalotrj20j805jjs2.jpg" alt=""></p>
<p>准确率、召回率就不解释了，大多数预测性的实验都以此作为评价指标。阿里用这两个值计算一个综合的评价指标 F1 作为排名依据。</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1eg6y25tsnij204601jt8j.jpg" alt=""></p>
<a id="more"></a>

<h3 id="思路">思路</h3>
<p>从这个题目，可以直观地想到我们机器学习中的<strong>Supervised Learning</strong>。另外，这是一个推荐问题，由此可以联系到亚马逊、Netflix 的推荐系统，想到 SVD等用户关联和协同过滤方法。此外，还可以发现一些经验规则，比如周期性、重复购买性等等。</p>
<p>协同过滤，一个非常直观的方法是用二部图得到推荐系数，同学用这个来做，效果不错。</p>
<p>我开始用的逻辑回归，但效果不好。现在想想，方法没问题，问题出在了特征的处理和最后推荐结果的选择上。</p>
<p>现在使用的是感知器，由于阿里初赛已经结束，无法提交结果以测试实验效果，只能把有限的本地数据分割成训练集和测试集来做。目前取得的 F1 为 4.3% 。虽然还很低，但至少证明思路是对的。</p>
<p>感知器属于线性分类器，也可以理解为最简单的神经网络。它非常直观，通过训练集，训练出每个特征对应的权值。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eg6ydhd8tbj20in0bedg5.jpg" alt=""></p>
<p>具体就不介绍了，可以参考 wikipedia。</p>
<h3 id="程序">程序</h3>
<p>程序代码用 Python 完成。如果去掉注释行、没有使用的函数，总共100行左右。使用了第三方包<code>sklearn</code>。</p>
<p>代码已经上传到<a href="https://github.com/zippera/dm_ali" target="_blank">Github</a>，欢迎讨论和给出建议。代码中做了注释，就不再多做解释了。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/机器学习/" term="机器学习"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[权力的动力]]></title>
    <link href="http://zipperary.com/2014/05/07/motive-of-power/"/>
    <id>http://zipperary.com/2014/05/07/motive-of-power/</id>
    <published>2014-05-07T12:16:22.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看林达的《一路走来一路读》，作者游历了美国很多有历史意义的小镇，比如打响国内战争第一枪的莱克星顿，比如出了两个总统的小镇昆西，比如格兰特与罗伯特李签署投降协议的阿波马托克斯…从眼前的小镇出发，林达慢慢讲述几百年前发生在这个小镇上的历史事件与经历历史的那些人。在阅读过程中，我的最大感受是惊讶于美国开国最初时政治家的理想主义、道德感与荣誉感，他们没有把政治作为谋取经济利益的手段，而是按照自己的理念企图让这个国家更好，让美国人民生活的自由而富裕。我很想引用林达的一段话：</p>
<blockquote>
<p>那个时候的布莱肯利奇，就像他们的祖父辈，像建立这个国家的早期领袖华盛顿、杰弗逊等一样，仍然保持着罗马古典共和主义的精神，他们用一种正面的态度来对待政治。在他们的眼睛里，政治，就像音乐、艺术一样，是高尚而道德的事业。政治家，就像艺术家、音乐家一样，是一种高尚而美好的生涯。好的艺术家要创作出美好的艺术，好的音乐家要创造出美好的音乐，而一个好的政治家，就要尽职尽责，把恪尽职守做到近乎完美的地步，而成败反而是第二位的事情。道德和荣誉，高于生命和权力。职责是政治家的天命，权力只不过是完成职责的工具而已。抱持这样的信念，他们有时候表现得几乎是天真迂腐，缺乏算计，毫无谋略可言。 在今天的政治运作中，人们越来越清楚，政治的清明，必须依赖制度的制约和平衡，而不是企盼政治家的个人道德完美。然而，这种近于艺术家般天真的政治观之可能存在，为我们留下了对“干净的”政治的最后一点信心。对于我们如此半生经历的人，几乎有一种精神救赎的意义。</p>
</blockquote>
<p>今天，那样的精神已经不复存在，至少没有很多人在坚守。困扰我很久的一个疑惑又出来了：为什么有那么多人在追求权力？Specially,为什么那么多人想竞选总统？</p>
<a id="more"></a>

<p>带着疑问，又去知乎寻找答案。这样的问题果然有人问过了，但失望的是，大家对此不感兴趣，回答者寥寥。在问题<a href="http://www.zhihu.com/question/20561533?rf=20637722" target="_blank">竞选美国总统的动力在哪？</a>下，得票最多的回答者认为是出于热爱，就像歌手忙碌于出唱片一样。这有点像林达说的那种人，但我认为今天大多数人不是这样的。 还有一个人讲述了他的竞选candidate：</p>
<blockquote>
<p>他会真正地和你聊一晚上怎么帮助选区所在的community，会一家一家拿着小联系跑每一个宿舍，每一家餐厅，来倾听你的需要，他的fund之前靠的都是自己on campus job剩出来的。<br>他说之后还会继续在这条路上走，或许会加入某个party。他希望成为WI最年轻的state legislature. </p>
</blockquote>
<p>我理解这是整个社会氛围造成的，当你耳濡目染大家都在真诚为community服务，都想尽自己之力让社区更好，自己也会自然而然这么做。但这仍然无法解释中国的官员。</p>
<p>就我个人的经历而言，做一个好官似乎没有什么可图的。比如在学校，新的班集体成立之初，为了班级管理的方便，会选出班委会为同学们服务。不像国外那种大家拼死拼活地竞选，我们几乎是在拼死拼活地躲避。甚而至于需要强迫每个人报出一个竞选意向。尽管这样，我们很多人还是庆幸于最后没有进入班委。为什么会这样？其实利弊一眼就可以测量：</p>
<ul>
<li>利：有机会和同学们接触更多…</li>
<li>弊：会耽误自己的时间、精力，有时还会耗费体力；需要对一些事情负责，办好了是应当的，办不好就要挨批评。</li>
</ul>
<p>总之，这是费力不讨好的事情。</p>
<p>那么中国的官员呢？据我了解，如果为官清廉，他们的收入并不高，也就是经济利益并不大，反而会肩负重大责任，就像班委那样。如果这样的人仍然孜孜于权力，我只能理解是<strong>治天下</strong>的理想了。然而，在中国，我很相信，理想主义者一定是少数，极少数的。那么我就不禁怀疑，大多数人为官，如果并不是为百姓谋福祉，难道是为了经济利益？我进一步怀疑这样的经济利益是否合法。</p>
<p>既然出于理想主义而为官的比较稀有，那么像新加坡那种公务员制度就比较合理了。新加坡的国家治理是按照公司治理的思路进行的，官员也是聘用制，并予以高薪，就像公司的经理人那样。反观中国，为官权力大，没有有效的监督，工资又很少，那官员们岂不是只能以腐败的方式获得经济收入，平衡心理？</p>
<p>我的问题：中国的官员们，除了经济利益，为官的动机是什么？</p>
<p>求解！</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Enough foreplay, do it]]></title>
    <link href="http://zipperary.com/2014/05/05/enough-foreplay,-do-it/"/>
    <id>http://zipperary.com/2014/05/05/enough-foreplay,-do-it/</id>
    <published>2014-05-05T00:52:33.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>实在找不出其他词句能够更准确地描述此时的感觉了。为什么用英文，因为最近在「扫黄打非」，中文写出来有些伤风败俗。。</p>
<p>vim, zsh, chrome, alfred…各种工具可以有效提高工作效率，所谓「工欲善其事，必先利其器」，一个讲究的程序员会花些时间打磨自己的工具，然后优雅地写代码。但是工具毕竟是工具，是工作之前的 foreplay,不可忘了主业，成了工具控，最后发现电脑里虽然装了一大堆好用的工具，电脑已经无敌，却没有做出什么东西来。</p>
<p>从这个概念推广开，就会发现我活到现在几乎依然处于 foreplay 阶段：上学。上学是知识的积累，为以后的工作储备知识、磨练技能，一句话——做准备。每天的 accomplishment 不是完成了多少工作，而是学习了多少知识。很多人会渐渐觉得上学上腻了，于我，估计就是渴望 accomplish something 了吧。</p>
<p>审视一下自己每天所做的事情：学 node.js，而没有写一个 web 程序出来用；读论文，而没有提出有价值的 idea，撰写论文并发表；写博客，往往也只是介绍所学所想，并没有创造什么；上课，依然在吸收知识…时间流逝，evernote 逐渐变大，却没有真正 do 什么。</p>
<p>foreplay 是重要且必要的，但千万不能沉迷于此，仅仅依靠 foreplay 就 sent to orgasm，足够的 foreplay 之后，就该 do it，就该 perform it。</p>
<a id="more"></a>

<p>现在是学生，学习为主业，但并不意味着只能学习。</p>
<p>比如：可以用 node.js 写一个好玩的 app 给大家用；可以一边用 mfc 做 app 一边学习它的文档；读论文时要带着目的、带着思考，不仅要理解所读论文，更要提出问题，进而考虑改进，如此才能加快出论文的进度；写博客，不要只当成 task 完成就万事大吉了，最好把每次写博客看作一个机会，练习把话说清楚讲明白，尝试提供一些新鲜的有价值的想法，而不只是总结陈词之类；至于工具，如果真的好用，那么就用起来，开始时可能不习惯，那么不妨多练习练习，如果实在用不来，那么果断抛弃，不要成为累赘；读书时，也不要满足于读了几个字、读了几页、读了几本书，在读书的时候一定不要着急，多停顿几次，琢磨琢磨作者的话，联系一下自己的经验、经历，或者自己在脑子里推演一下作者的思路…</p>
<p>上面这些想法，一句话概括来说就是「玩真的」。不是说我有一周的时间，需要找些事情添加到日历，然后依次完成这些事情就 okay 了；而是有一些事情真的想做，真的想做好，见缝插针也要把它完成，有了这种态度，才能认真的玩。</p>
<p>最近看的东西实际上并不少，却总有患得患失的感觉，想来想去，其实还是 do 的比较少，「玩真的」比较少，这已经变成我的习惯了，亟需有意识地改掉。</p>
<p>Hence, from now on, do it!</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[《乡土中国》笔记]]></title>
    <link href="http://zipperary.com/2014/05/02/xiang-tu-zhong-guo/"/>
    <id>http://zipperary.com/2014/05/02/xiang-tu-zhong-guo/</id>
    <published>2014-05-02T02:49:41.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>《乡土中国》这本小册子是之前某学院做活动时我从那个书摊里挑拣到的，久仰大名，却因为这土气的名字没有认真对待。小册子印刷封装都很精美，薄薄的，有了些读下去的动力。一直把它放在床头的小盒子里，晚上从实验室回到宿舍，上床后读一二章，没有赶时间的压力，随心而读。这本书虽然写于上世纪三十年代左右，但今天看来一点都不因时间久远而困难，这应该得益于作者对问题的深入理解和清晰表达。很久以来，从未有如这次一般，文字能如此有力地敲打我的思想，让我感觉「嗯，这本书真的让我受益良多」。这样的感觉伴随着读书始末，足以佐证此书在我心中的价值。</p>
<p>由于是随心而读，没有做笔记，没有勾画，没有边读边梳理。读完之后，感觉有东西压在心中，不写出来不痛快，就像费孝通说的「紧张 - 发泄 - 行动 - 愉快」，所以在 Evernote 里随便写了写读完此书后脑中留存的一些印记。这不是比较正式的读书笔记，可做读后感吧。</p>
<a id="more"></a>

<p>以下是内容，各条之间不讲究先后顺序。</p>
<p>四种权力：</p>
<ul>
<li>横暴权力：由冲突产生，一方要反抗，另一方要压迫，取得的短暂平衡状态。目的是从被压迫者身上获得利益。</li>
<li>契约权力：由合作产生，基于意志共同协商产生一个契约权力，目的是为了总的利益最大。</li>
<li>长老权力：乡土社会中的长幼关系，长辈教化晚辈。不是以上两种。长辈让晚辈成为一个合乎习俗的人。</li>
<li>时势权力：社会快速变迁时，出现英雄，带来和传播新的思想，并对异己思想加以排挤。</li>
</ul>
<p>乡土社会，社会结构基本不变，父死子继，不变结构。环境也几乎不变。因而一生中所遇到的所有问题，几乎都有长辈经验，因而长幼之序能保证社会的稳定。</p>
<p>长幼之序成为观念，成为正确。但环境是变化的，社会是变迁的，很多时候长并不一定对，幼又不可不听。这时会加注释地接受，表面听从，实际扭曲。名与实分离。 中国重孝，孝即不违，即听从。</p>
<p>乡土社会，人们扎根土地，安土重迁，很少会移动。同时繁衍会使得周围全是亲属。熟人社会：<br>有很少的新知识需要表达，因而一个眼神，一个动作，一个字都能把意思表达清楚（符号的象征意义已经 share）。他们不需要识字，不需要新知识，不需要流行，土就足矣了。</p>
<p>亲属是一根树上生出的，不分你我。权力义务关系不对称时，也只能忍受。所以最好别跟亲属谈钱。 乡村中的外地人通常作为交易的媒介，集市通常也不在村里，有很多陌生人，这样才可以谈钱。</p>
<p>中国的社会关系是延伸性的（差序），从自己，到亲属，到朋友，逐渐外延，根据情况伸缩，没有明确的界限，因而也没有很好的团体观念。国外的关系一般是确定的，家庭只是夫妻二人，孩子是临时的，家庭关系依赖情感（中国是依赖合作，因而冷冰冰），根据不同的思想从属不同的团体，互不冲突，在团体中也是平等的。</p>
<p>乡土社会，人们根据欲望做出的行为，通常能使最终利益最大化（比如食色性也，味觉好方能生存，色方能生育繁衍）。欲望的背后目的，其实不是生存，而是文化。比如从小吃蒜，只是因为长辈们吃蒜。社会变迁，按照欲望行动未必好使，为了使利益最大化，就需要自觉，需要计划，根据的是「需要」，而不是欲望。</p>
<p>文化是所有人认同的，法律是部分人认同的，有争议，暂时按此行事。乡土社会，合乎礼仪就不会有矛盾，有矛盾说明没有守礼，这是丢人的事，所以讲究无讼（判案时先各打板子，谁让你不守礼了）。但社会在变，很多新东西，旧文化已经无法适应，这时候需要诉讼，需要专业的人来提供咨询，律师。</p>
<p>（End）</p>
]]></content>
    <category scheme="http://zipperary.com/categories/读书笔记/" term="读书笔记"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[理解 javascript 回调函数]]></title>
    <link href="http://zipperary.com/2014/04/21/js-callback/"/>
    <id>http://zipperary.com/2014/04/21/js-callback/</id>
    <published>2014-04-21T02:22:44.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看 express,满眼看去，到处是以函数作为参数的回调函数的使用。如果这个概念理解不了，nodejs、express 的代码就会看得一塌糊涂。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>app.use(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> {</span>
    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>);
    err.status = <span class="number">404</span>;
    next(err);
});
</pre></td></tr></table></figure>

<p><code>app</code>是对象，<code>use</code>是方法，方法的参数是一个带参的匿名函数，函数体直接在后面给出了。这段代码怎么理解呢？我们先来了解<em>回调函数</em>这个概念。</p>
<p>首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span>
{</span>
	<span class="keyword">return</span> a + b;
}
</pre></td></tr></table></figure>

<p>这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量<code>doSomething</code>。接下来我们调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.log(doSomething(<span class="number">2</span>,<span class="number">3</span>));
</pre></td></tr></table></figure>

<p>这样会输出<code>5</code>。</p>
<a id="more"></a>

<p>回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行。说来抽象，看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// To illustrate the concept of callback</span>
<span class="keyword">var</span> doit = <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>
{</span>
    <span class="keyword">var</span> a = <span class="number">1</span>,
        b = <span class="number">2</span>,
        c = <span class="number">3</span>;
    <span class="keyword">var</span> t = callback(a,b,c);
    <span class="keyword">return</span> t + <span class="number">10</span>;
};
<span class="keyword">var</span> d = doit(<span class="function"><span class="keyword">function</span><span class="params">(x,y,z)</span>{</span>
    <span class="keyword">return</span> (x+y+z);
});
console.log(d);
</pre></td></tr></table></figure>

<p>先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。</p>
<p>下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。</p>
<p>上述代码的执行过程是：</p>
<p>调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。</p>
<p>回到最初的例子，<code>app.use(...)</code>是函数调用。我们可以想象，之前一定定义了一个 use 方法，只是这里没有给出。这两个例子一对比，就可以马上理解了。</p>
<p>在使用nodejs、express 的时候，不可能每个方法或函数我们都要找到它的函数定义去看一看。所以只要知道那个定义里面给 callback 传递了什么参数就行了。然后在调用方法或函数时，在参数里我们自己定义匿名函数来完成某些功能。</p>
<p>Over!</p>
]]></content>
    <category scheme="http://zipperary.com/categories/nodejs/" term="nodejs"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[wiz to evernote]]></title>
    <link href="http://zipperary.com/2014/04/13/wiz-to-evernote/"/>
    <id>http://zipperary.com/2014/04/13/wiz-to-evernote/</id>
    <published>2014-04-13T07:04:46.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>Evernote 刚刚诞生不久我就成为了它的用户，后来中国有趋势成为用户第二多的国家，于是印象笔记诞生，同步的速度快了不知道多少倍。由于对它的依赖，我的笔记数量迅速增加。当时用的是 windows，印象笔记的优化可能还没做好，随着笔记量增大，笔记经常会卡顿到无法忍受。开始考虑其他的笔记应用。</p>
<p><strong>印象笔记当初让我很难忍受的另外两个原因：</strong></p>
<ul>
<li>流量限额，只有60M，几乎没办法保存图片和附件。</li>
<li>没有格式刷功能，非常不便。关于这个问题我咨询过印象笔记的官方微博，回应说，印象笔记是基于 html 的，技术上做格式刷的难度太大。于是我就不抱期望了。</li>
</ul>
<p>经过各种寻找、尝试、推荐，最后确定用国内的「为知笔记」。由于是国内的，其安全性是我最大的担心，不过在网上看到很多貌似靠谱的人推荐，我也就不消怀疑了。</p>
<p><strong>为知笔记好用的地方：</strong></p>
<ul>
<li>方便的格式刷功能。</li>
<li>个人用户流量不限。</li>
<li>windows 上非常流畅。</li>
<li>支持各种小插件，比如 markdown 写作。</li>
<li>与社交账户的结合。</li>
</ul>
<p>于是我就下定决心转过来。当时印象笔记转到为知笔记是没有很好支持的，需要太多的手工劳动，必须要坚定的决心和顽强的意志才行。</p>
<a id="more"></a>

<p>经过一番摧残，终于在为知笔记安了家，然后相安无事。</p>
<p>过了很久，我买了Mac，用为知笔记的 Mac 版，太过鸡肋，功能少的可怜，各种不方便。为知笔记一直在进步，但Mac 版的功能始终太过简单了。这几个月又接连发生笔记乱码、丢笔记、笔记图片挂掉的情况，苦不堪言，忍无可忍，必须换笔记了。找了一圈，印象笔记的 Mac 版是做的最好的。得，还得回来。</p>
<p><strong>为知笔记的 Mac 版有这些问题：</strong></p>
<ul>
<li>笔记乱码。我的一个重要笔记内容全编程 html 码了，通过云端都无法恢复，痛苦。</li>
<li>笔记丢失。好几条笔记懒腰斩断，后面的内容全没了。</li>
<li>图片丢失。有些笔记里的图片挂掉，永远挂掉了。</li>
<li>搜索功能鸡肋。几乎可以认为没有搜索功能了，对于一个笔记软件，这是致命的。</li>
<li>没有无格式粘贴功能。</li>
</ul>
<p>回来可麻烦了，现在的笔记都提供了从印象笔记导入的功能，却几乎都没有导入到印象笔记的功能。哎，还是得手动。</p>
<p><strong>经过探索，目前找到的最好的方法如下：</strong></p>
<ol>
<li>参考<a href="http://www.zhihu.com/question/20287008/answer/23591722?utm_source=weibo&amp;utm_medium=weibo_share&amp;utm_content=share_answer&amp;utm_campaign=share_button" target="_blank">知乎</a>里面提到的这种方法，把能转移的全部转移。</li>
<li>上面的情况只能导入部分笔记，其他笔记还是需要手动拷贝。直接在客户端（转移操作都在 windows 客户端进行，因为 windows 客户端的功能是最丰富的。）拷贝会遇到图片挂掉或丢失的情况，或者其他格式错误。解决方法是：打开为知笔记的网页版，从网页版的笔记拷贝，这样能完美的把笔记内容和格式拷贝到印象笔记。</li>
</ol>
<p>回来了，印象笔记的不足依然没变，但相对于为知笔记的致命 bug，那些不足也微不足道了。<strong>印象笔记的 Mac 版用了几天了，非常好用。</strong></p>
<ul>
<li>支持笔记搜索和笔记内搜索，可以上下查找，很方便。</li>
<li>笔记支持各种方式排列，我一直在用根据更新时间的排列方式。</li>
<li>支持各种快捷键操作。</li>
<li>支持共享笔记，可以与好友、同事共同维护一些笔记。</li>
</ul>
<p><strong>另外推荐几个 tips：</strong></p>
<ul>
<li>在微博关注<a href="http://weibo.com/myyxbj?topnav=1&amp;wvr=5&amp;topsug=1" target="_blank">@我的印象笔记</a>，以后看到喜欢的微博，评论、转发时只要评论一下<code>@我的印象笔记</code>就可以自动记录到印象笔记。</li>
<li>微信关注「印象笔记」后，也可以轻松把微信内容保存到笔记中。</li>
<li>Chrome 插件<a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc" target="_blank">印象笔记-剪藏</a>，真心的良心产品。</li>
</ul>
<p>比较遗憾的是，印象笔记仍然没有做出「格式刷」，我一点也不指望了。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/IT杂谈/" term="IT杂谈"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[An Intuition to Locality Sensitive Hashing]]></title>
    <link href="http://zipperary.com/2014/04/01/lsh/"/>
    <id>http://zipperary.com/2014/04/01/lsh/</id>
    <published>2014-04-01T11:47:00.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>在 Stackoverflow 的「Machine Learning」标签下随便看，看到一个<a href="http://stackoverflow.com/questions/12952729/how-to-understand-locality-sensitive-hashing" target="_blank">How to understand Locality Sensitive Hashing?</a>的问题，刚好看视频跟踪时看到有一个 Coherency Sensitive Hashing，莫非两者有不可告人的联系。。索性就学习一下。</p>
<p>先用例子直观地说明一下，请看下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ef0c2v4ps1j20nf0ddt9l.jpg" alt=""></p>
<p>上图是一个平面，其中有一个红点和一个黄点，都是二维向量。我们的目的是通过 LSH 方法近似求得这两个点的余弦相似度。</p>
<p>余弦相似度是求向量相似度的一种方法，在图像匹配中很常用。</p>
<p>怎么求呢？</p>
<p>现在，在这个平面上，随记产生 n 条过坐标零点的线，这里 n 取6.</p>
<p>分别给红点和黄点一个 hash 表，实际就是一个二值数组，每个元素取0或1，如左上图所示。白色代表0，黑色代表1.这个 hash 表叫做signature。</p>
<p>先看红点，分别看看这6条线在红点的上方还是下方，并分别标注为0/1，填写在signature 中。需要注意的是，这两个 signature 对应元素代表同一条线。</p>
<p>映射完后，计算这两个 signature 中对应元素不同的个数（hamming distance），比如这里是1个，即最后一个。这有什么意义呢？看图，两个点中只有一条线。由于向量的夹角在[0,PI]之间，有6个线，两个点中只插入了1条，那么两点之间的夹角就可以近似为<code>PI * 1/6</code>。</p>
<p>如图所示：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ef0ccvna1dj20of0de405.jpg" alt=""></p>
<a id="more"></a>

<p>当 n 足够大时，这个估计会非常接近真实值：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ef0coa709fj20dm02qjrf.jpg" alt=""></p>
<p>实际上 LSH 是用采样的方法来近似解析方法求得的真值。至于为什么不直接用解析的方法，我现在还不清楚，可能有些时候解析方法无法求吧。</p>
<p>我觉得这东西跟用蒙特卡洛方法近似求解不规则多边形的面积很像。所谓的 hash，只是一个小 trick 而已。</p>
<p>至于名字「Locality Sensitive Hashing」，应该是说，位置上越接近的向量，其 hash 越相似。</p>
<p><a href="http://stackoverflow.com/users/1667256/greeness" target="_blank">greeness</a>提供了一段用 python 写的 demo，很值得看一看：</p>
<script src="https://gist.github.com/greeness/94a3d425009be0f94751.js"></script>

<p>代码很简单，不介绍了。值得注意的是其中的移位运算很巧妙，值得学习。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/机器学习/" term="机器学习"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Suggestions on English Learning（试读）]]></title>
    <link href="http://zipperary.com/2014/03/30/suggestions-for-learning-english/"/>
    <id>http://zipperary.com/2014/03/30/suggestions-for-learning-english/</id>
    <published>2014-03-30T03:30:42.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Introduction">Introduction</h3>
<p>经常有朋友询问怎么学英语，有的是要考四六级，有的是想看论文，有的是已经工作的希望能够更加通畅地阅读英文资料。这些人中，与我同为计算机出身的比较多。与英语专业的学生不同，我们没有那么多的时间、精力和师友资源来浸淫在英语的世界中慢慢打磨自己，很多人也缺少对英语足够的兴趣，而只能在课余、工作之余，抽取些许时间，在「学以致用」的动力下努力提高自己的英文水平。</p>
<p>我本科学的是「信息管理与信息系统」，研究生在读「计算机科学与技术」，在英语学习方面，跟大家有几乎一样的先天条件和成长环境。因此，也许我的英语学习之路能给与我类似的读者一些可资借鉴之处。</p>
<p>为防止被指责为「理论家、学院派、纸上谈兵大将军」，我应首先证明一下自己是有些资格谈论这个问题的。稍列一下我的英语成绩：</p>
<ul>
<li>中学、大学的英语相关考试在学校范围内位居 Gaussian 分布均值位置左右。</li>
<li>中学和大学参加了几次全国英语能力竞赛，一等奖（worse than 特等奖,better than 二等奖）</li>
<li>英语四六级分别622、633</li>
<li>考研英语84/100</li>
<li>考过托业、GRE</li>
</ul>
<p>可以看到都是一些考试，没办法，我又不是英语专业的，只能提供这些 certificate 了。</p>
<p>从听说读写的角度看，「说」是个短板，周末去英语角练练。。</p>
<p>根据不同人惰性（或积极性）的不同，我分两个层次谈谈英语的提高：简单粗暴式和千锤百炼式。</p>
<a id="more"></a>

<h3 id="简单粗暴式">简单粗暴式</h3>
<p>都知道学英语要打好基础，什么背单词啦、记短语啦、研习语法啦，说得头头是道，大家都觉得有道理，可是有几个人会去认真做？这是可以理解的，因为大家都很忙，有很多比英语重要的事，这个学习过程是应该放在上学读书阶段的，当时没有利用好，如今只能望洋兴叹了。对于这样的，就只能简单粗暴了。</p>
<h4 id="听">听</h4>
<ol>
<li>推荐下载一个应用 Umano，有点像播客，标准清晰的英语，合适的语速，有文稿。（或者也可以听《新概念英语》）每天花几分钟听一个即可，每一个反复听三天。听的时候把自己置身于那个环境中，好像朗读者在你的对面跟你讲话，体会他/她朗读时的抑扬顿挫。第一天不必要求自己每个词都听懂，你的目的是尽可能听出更多的信息。然后看文稿。第二天已经有文稿的印象了，再听一遍，看看是不是听出了更多的东西。第三天就不要想着文稿了，直接听，听完后在自己的笔记本上草草地列个框架。</li>
<li>看美剧。强烈推荐《老友记》，第一季不太搞笑，越到后面越精彩。每一集之间的剧情联系不多，所以，先在 wikipedia 上了解一下主要人物的姓名、关系、性格，然后随便挑一集看。一共十季，建议只取某一季（我是第六季），反复来回地看。第一次看字幕，这样能看懂。以后再看的时候，逐渐减少对字幕的依赖。当你最后不带字幕地看，依然能在适当的笑点出笑出眼泪，就说明听力提高不少了。还是那样，要入戏，置身于戏中的场景，品位英语的强调。为什么推荐这么老的一部剧？简单、搞笑。发音相当标准、好听，没有什么晦涩的学术用语，都是日常中使用的地道英语。当然，如果你想用Big Bang来练习，我先佩服一下。</li>
</ol>
<h4 id="说">说</h4>
<p>上一步练习听力的过程，同时也对「说」有很好的提高。估计中国的学生对「说」没有特别大的需求，而且提高也挺困难的，我就不说了。</p>
<p>上次去参加「老池老友会」，Infoq 的全球站创始人在茶歇时跟我打招呼，一下语塞，痛下决心提高口语。目前的方案是，周六参加英语角。谁有欧美的朋友可以帮我介绍下哈。</p>
<h4 id="读">读</h4>
<p>大多数询问我的人，主要目的是提高阅读英文资料的能力。我把阅读时的障碍分为以下几种：</p>
<ul>
<li>因为背景知识的匮乏而看不懂：比如我刚开始看视频跟踪的论文，一头雾水，这不是英语的问题，因为读中文版也读不懂。那只有先去恶补背景知识了。</li>
<li>因为词汇、语法问题看不懂：一会细说。</li>
<li>读的慢：之前我看英文文档也很慢，但其实里面的词汇我都认识，语法我都明白，长句我也能看懂，看的慢，主要还是因为它是外语，不是母语，不够习惯。去年看了一本原版《The Hobbit》和半本《指环王》，作为IT 界的需要大量阅读英文资料，比如 Wikipedia,Stackoverflow,各种 Tutorial，各种论文，看的多了，速度就一点一点提上去了。前几天在网上看了一套关于「图像处理」的教程，全英文，看完的速度还是可以的。</li>
</ul>
<p>词汇问题的，如果你要读的资料不用精读，那么甚至可以不查词典，直接猜即可。猜的方法就多了，根据语境（上下文）啦，根据词根词缀啦等等。如果需要搞明白，那就查词典。大家读英文资料主要都是集中在特定的领域，比如我的图像与视频，比如编程。这里面用到的词汇会反反复复出现。所以大家可以把生词记在本子上，或 Evernote 上，吃完饭坐在那儿就看一会。以后再遇到的时候，只要是查过的，坚决不再查，努力回忆，实在不行才看笔记。</p>
<p>当然，如果你有足够的决心提高英语，集中搞定单词比较治本。</p>
<p>因为句子的复杂结构而看不懂的，需要练习「枝干法」理解句子。就是找主干，主谓宾，其他各种补语状语修饰成分都是叶子。具体属于哪种修饰不需要知道，只要能明白它是怎么修饰它的对象的就行。比如「the place where you go」，后面的就是详细解释 place 的，哪个 place？你去的那个 place。刚开始的时候花些时间集中练练，以后阅读的时候要有主干枝叶的意识，久而久之就会无意识地通过结构理解句子了。</p>
<p>至于一些短语啊，比如 would rather,in spite of ,with regard to，当成词汇来记吧。</p>
<h4 id="写">写</h4>
<p>关于写，我是用「show off」的思维去做的。简单来说，就是我学会了某个单词、短语、句子结构，我就傻傻地认为它很高级，在写文章的时候千方百计塞进去，然后自认为文章华丽丽。在写文章的时候给予自己很高的自由度，就是我可以随便写，可以发挥，可以联想。写长句，用各种状语定语之类，英语的修饰语在后面，很容易写长的，长句很唬人，也很锻炼自己的英语思维。要这样想，自己学习英语、积累单词都很辛苦的，终于有机会用有机会 show off 了，你不拦着我我就把所学都施展出来。</p>
<p>是不是很扯，但这样练习真的很有效。当然，在考试中要适当的 hold 一些，别自由地跑题了。其他的，比如文章的结构、起承转合、写作手法，这个话题就大了，你不会去了解，我也不废话了。</p>
<h3 id="千锤百炼式">千锤百炼式</h3>
<p>想想我们学汉语用了多少功夫，英语虽然简单得多，但是欧美用了多个世纪的庞大的语言系统，怎么能那么轻而易举地拿下！</p>
<h4 id="词汇">词汇</h4>
<p>想象一下，当你几乎认识所有单词，通篇看去没有生词，是不是很爽，是不是，是不是？</p>
<p>『是！但这是不可能的事啊。。』</p>
<p>『Nope，而且很多人做到了。』</p>
<p>大家四六级基本上都考过了。在四六级词汇的基础上，把一本 GRE 红宝书搞定，你就能在阅读中几乎遇不到生词了。</p>
<p>『靠！滚！』</p>
<p>『有一本书叫《17天搞定 GRE 单词》，我用过，我说这是可能的。』</p>
<p>『Nani？！』</p>
<p>『但是若没有强大的动力和17天全脱产的时间，你是不会做的。』</p>
<p>『And？』</p>
<p>『你可以背一本托福，简单的多，但道理都是这么个道理，单词是可以集中搞定的。』</p>
<p>对话结束。推荐积极性高的同学用这种办法搞定一本单词书，既有趣又有益。而且只需要达到每个单词看到时知道其最主要的一条意思即可，拼写什么的不必着急。另外，一定要先学习一下构词法，每个单词是由哪些词根词缀构成的，非常好玩，受益无穷。</p>
<p>除此之外，遇到生词后可以使用「有道词典」，查过的单词都给保留了记录，方便复习。其他词典没试过，应该也可以。</p>
<p>一个单词的意思是这样的，放在某一篇文章中，可能就不好再这么解释了，这就是语境对意义的微改变。所以，对于单词，不必精确地记忆其中文意思到底是哪个词，只要知道其大概意思即可。</p>
<h4 id="语法">语法</h4>
<p>我的语法功底是中学时搞定的。当时英语教学的主要任务除了单词就是语法，更多的还是语法。现在总结下语法的学习，我认为的最佳路径是：</p>
<p>做好彻底突破的心理准备。</p>
<p>买本语法书，各个击破的那种。</p>
<p>对于某一个语法块，比如倒装句，给自己几天的时间。倒装句有哪几种，先理解了，然后做笔记，列出来有哪几种，每种下面摘抄一个你喜欢的例句。这几天的时间就是把这几个句子念熟或背熟，直到感觉倒装句不别扭。比如，我至今还记得中学时背过的一个「So clearly does he speak English that he can always make himself understood」。你要觉得只有一个小语法点的句子不值得你背，可以自主添加一些修饰成分啊，让句子更 cool 一些。</p>
<p>到最后，也许大多数的句子你不记得了，但语法已经进入感觉，你已经搞到手了。</p>
<h4 id="长句">长句</h4>
<p>写长句上面提到了，阅读中遇到长句，上面也说过可以使用枝干法分析句子结构。长句是英语学习中的一个老大难问题，对于想要千锤百炼的同学，可以考虑找本书集中学习一下。</p>
<h3 id="考试">考试</h3>
<p>我想说，每种考试都是有技巧可言的，英语中常见的题型「听力，选词填空，完型填空，阅读，改错，作文」更是如此。由于读者未必需要考试，考试的形式也未必是这些，我就不多说了，有问题反馈时再说吧。</p>
<h3 id="总结">总结</h3>
<p>我上面说的这些，你可以根据自己的情况借鉴，或者先打个折扣再借鉴，或许根本就不适合你，那么可以去知乎、沪江之类的地方，有很多不错的建议。我毕竟不是专业的，在学校时做报告也是按照题型来分析解题方法的，对于这种 general guide 没有足够的底气。</p>
<p>我写这篇文章之前，大家问到的时候还都是「怎样学英语」这种宽泛无边的问题，还是希望能提问的具体一些，这样也更有可操作性。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/English/" term="English"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[视频跟踪]]></title>
    <link href="http://zipperary.com/2014/03/28/video-tracking/"/>
    <id>http://zipperary.com/2014/03/28/video-tracking/</id>
    <published>2014-03-28T08:32:11.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>下午老板叫去开会，心里就预感有事情要发生，该来的不该来的还是不可阻挡的来了。</p>
<p>从去年开始，我的研究方向就一直是视频跟踪，这也是我们实验室的传统课题。从一无所知，没有任何图像方面的基础，看论文被各种术语困住无法前行，一个基础一个基础的攻破，查阅了巨多的资料，看了十几篇论文，阅读、修改代码，反复研究，在几乎没有指导的情况下终于拨云见日、渐入佳境；理解了贝叶斯框架在视频跟踪中的应用，理解了粒子滤波、卡尔曼滤波、马尔可夫蒙特卡罗采样与视频跟踪的结合；看论文的速度也加快了。</p>
<p>期间得到周师兄的帮助，尤其在找论文、看论文方面给了很多有用的指导。周师兄写出的粒子滤波的 matlab 代码也让我对其有了更为形象的了解。</p>
<p>虽然这个方向前路如何我不得而知，科研的风险始终摆在那里，但学有所得的快乐是有的。</p>
<p>现在，我的方向是「视频大数据检索」了，但愿能用的上前面这些积累吧。</p>
<a id="more"></a>

<p>在告别这个方向之际，我写这篇文章，梳理一下目前对视频跟踪的些许了解。</p>
<p>视频跟踪一般的方法是：在第一帧中用矩形框圈定目标 object，比如一个行人。在第二帧中，在不同的位置选择大小不同的矩形框，跟第一帧中框内的 object 比较，如果第二帧中哪个框中的内容跟第一帧框中的内容最相似，那么就选这个框中的内容为第二帧中跟踪到的 object。然后开始第三帧，以此类推。</p>
<p>这里面涉及两个问题：</p>
<ol>
<li>第二帧中怎么选择框？ 由于框的大小和位置都可以遍，如果用穷举法，那么几乎是无穷多个，这样效率就太低了。一般的做法是，在上一帧得到的 object附近洒粒子（如用高斯分布采样），以每个粒子为中心画框，大小可以不变，也可以根据高斯分布采样确定。这样就比穷举法要有效的多。这里的概念就是 proposal，提议分布。</li>
<li>怎么确定某一帧中的某一框与第一帧中object 的相似度？这就是要确定要使用的外观模型了。一般可以用颜色的 HSV 直方图，然后通过巴氏距离确定相似度。</li>
</ol>
<p>视频跟踪，本质上可以建模为 HMM。State 为 object 在某一帧中的位置；Observation 为颜色直方图；状态转移矩阵为上一帧中的 object 位置到这一帧中各位置的概率，即 proposal；发射概率即该位置产生这个颜色直方图的概率，即 likelihood。</p>
<p>在 HMM 上应用贝叶斯框架，视频跟踪问题就可以表示为：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eevl1f4jawj20f7019mx4.jpg" alt=""></p>
<p>这里编辑公式不方便，简单介绍一下上述公式的四项：</p>
<p>x 为 state，即这一帧（t+1时刻）中 object 在这个位置 x；y 为 observation，即观察到的这个 x 对应的框中的颜色直方图；第一项就是贝叶斯框架中的后验概率。</p>
<p>第二项是 HMM 中的发射概率，在贝叶斯中叫做 likelihood。</p>
<p>第三项是 HMM 中的转移概率矩阵，在贝叶斯中叫做 prior，先验概率。</p>
<p>第四项是上一帧（t时刻）的后验概率。</p>
<p>学过 HMM 的同学应该对这样的式子很熟悉。</p>
<p>注意到，这里面有积分，实际在用时是很难 analytically work out 的（当满足某些条件时，可以用卡尔曼滤波解决）。所以，视频跟踪领域中，基本上都是采用采样的方法来做。</p>
<p>关于采样，这是一个很大的话题，我前面作文介绍过。一般都是采用基于粒子滤波的方法，比较新的是使用基于粒子滤波的 MCMC 方法。粒子滤波和 MCMC 耗费了不少精力才弄懂，以后应该会专门作文介绍。</p>
<p>视频跟踪大概就是这么回事，具体的方法和例子，以后再介绍。</p>
<p>近年这个领域发表的论文，主要是解决视频跟踪中目标的运动和外观突变的问题。</p>
<p>这个领域值得关注的有 K.M.Lee，M.H.Yang等。比较新的方法有 incremental learning,sparse representation,patch,grid 等。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/机器学习/" term="机器学习"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[haste makes waste]]></title>
    <link href="http://zipperary.com/2014/03/24/haste-makes-waste/"/>
    <id>http://zipperary.com/2014/03/24/haste-makes-waste/</id>
    <published>2014-03-24T13:59:14.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>在写这篇文章时，精神已经十分萎顿。看了一天的论文和代码，想复习一下久违的 python，却发现环境中只有 python，<code>pip</code> <code>ipython</code>这些工具都没有。在线安装吧，久等没反应。下载 pip 安装包，以6KB/s 的龟速蹒跚走来，本已憔悴，险些喷血。看了一圈，什么都没了兴致，只有打开我的 Mou，与文字静处。</p>
<p>最近，除了学就是玩，感觉器官随时 open to receive and respond，没有独处，没有静思，离自己越来越远，越来越不自在。诸多不顺的累积，开始在精神和肉体上产生不良的反应，是时候暂停一下，跟自己有个对话了。</p>
<p>先说一说近来在做什么吧。</p>
<p>上课，每天差不多只有一节。一共五门课，老师们水X的，最后我只有从「数值分析」中才能学有所获，其他老师的讲课水平让我痛恨考到了这所学校。</p>
<p>课少，加上逃课，其他的都是自由时间。</p>
<p>这些时间中，在导师和师兄的指导下，看了几篇论文，基本上都是关于用贝叶斯框架做视频跟踪的。论文只全文通读一篇，不懂的地方有很多，等着讨论时向师兄请教。另外，在没有任何指导的情况下，我对视频跟踪的一些基本问题都没有搞清，所以自己一直在 google and reading，尤其是 particle filtering, mean shift, MCMC，边读论文边学习，反复磨合，感觉自己的理解在校正和加深。particle filtering 和 mcmc 还简单的用 matlab 模拟了一下。</p>
<a id="more"></a>

<p>z 和 j 都在忙项目，一个在 c++，一个在 oracle，认真的解决问题。我在搞理论，虽然不如写代码的畅快、见效明显，但我只能安慰自己「这玩意儿更高级」。不过啊，我有时又想，计算机领域如此之大，我读研三年的主要精力就都放在视频跟踪这个虽重要但小小的环节上嘛。除了发论文的需要，我还要考虑未来工作的需要。因此，老师不要怪我脱轨開小差。</p>
<p>宿舍里，缺了一个主力，卧谈会也发动不起来了，哎。</p>
<p>为了 expand 技能树，我希望给自己额外增加一些任务。比如在 python 方面继续提高，看完《算法概论》，做 github 上的100个 projects，提高 js，好好学一下 nodejs 或 rails。这还没写上读研要用的 matlab 、C++、计算机视觉的自学。光看这个 list，就开始有点焦头烂额。</p>
<p>西方有言：「Haste makes waste」，就是说着急了反而会浪费效率。比如我这焦头烂额无从下手，就是很不对的状态。</p>
<p>所以，还是要有所牺牲，做好权衡，安排好轻重缓急，一件一件的事慢慢做，有进步才是最重要的，不要对自己要求太高。</p>
<p>不好意思取消了联系方式中的 QQ 号，因为加的人很多，基本都是 hexo 安装遇到问题，问题也都很类似，甚至有很多是我博客里说到，而读者没注意到的。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Play Github]]></title>
    <link href="http://zipperary.com/2014/03/19/play-github/"/>
    <id>http://zipperary.com/2014/03/19/play-github/</id>
    <published>2014-03-19T13:46:14.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>今天花时间把 github使用中的一些疑点消灭一下。</p>
<h3 id="fork_&amp;_watch_&amp;_star">fork &amp; watch &amp; star</h3>
<p>到 github 中某人的某个 repo中，会在右上角看到这样的标签：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eelei341aoj20us01wglm.jpg" alt=""></p>
<p>原来一直困惑为啥要有三个，一个 fork 不就得了嘛，其实有三个还是很有必要的。</p>
<p><strong>fork</strong>: 把该 repo 拷贝到自己的账户下，相当于成为自己的 repo。不同之处是可以通过<code>pull request</code>和 original 的那个建立联系。</p>
<p><strong>watch</strong>: 分为三种级别：not watching,watching,ignore.其实就是用来设置提醒的，比如watching，该 repo 有任何 update 都会收到邮件或 github 中的通知；ignore 就是不接收任何通知。</p>
<p><strong>star</strong>: 可以理解成「收藏」，这个 repo 的 update 不会出现在 news feed 中。在主页通过「star」标签可以查看自己 star 过的 repo。</p>
<p>一般情况下，遇到好的 repo 想要收藏，就 star。想要自己改改、完善一下，可以 fork。想追踪它的某些 update，可以 watch。</p>
<a id="more"></a>

<h3 id="pull_request">pull request</h3>
<p>比如 tommy351的 hexo 这个 repo，我 fork 了一下。在我这边修改后，想要告诉 tommy351「我完善了一下，你把我修改后的版本合并到你的 repo 吧」，那么我可以向 tommy351发送一个 pull request。</p>
<p>发送的步骤是：在我这边的 hexo 中，点击右侧的「pull request」，然后「New pull request」，然后查看一下我对 tommy351的 repo 做了哪些改变，确认没错之后，点击「Create pull request」，填写一下说明，即可发送。</p>
<p>tommy351收到我的「pull request」后，如果觉得好，可以 merge，这个就不是我的事了。</p>
<h3 id="branch">branch</h3>
<p>新建一个 repo，默认的branch 是 master。master 作为主分支，要稳定。我们进行迭代开发时，可以新建一个 branch，在这个 branch 中开发，搞定后再合并到 master 中。这样的流程比较合理。</p>
<p>创建： <code>git branch test</code>，会新建一个 test 分支，并拷贝 master 的内容到这个分支下。</p>
<p>切换： <code>git checkout test</code> 从 master 分支切换到 test 分支。</p>
<p>查看： <code>git branch</code> 看看这个 repo 下有哪些分支了。带星号的为当前分支。</p>
<p>删除本地分支： <code>git branch -d test</code></p>
<p>删除远端分支： <code>git push origin :test</code> ，注意冒号的意思是删除。</p>
<p>在 test 下的其他操作，如add,commit,push和在 master 下是一样的。</p>
<p>如何合并两个分支呢？</p>
<ol>
<li>通过<code>git checkout master</code>切换到主分支。  </li>
<li>通过<code>git diff test</code>查看这两个分支的不同。</li>
<li>确认无误后，通过<code>git merge test</code>把 test 合并到 master。</li>
</ol>
<h3 id="pull_and_fetch">pull and fetch</h3>
<p>这两个操作都是把别处的 repo 拉到这里来，有什么不同嫩？</p>
<p><code>git pull</code> = <code>git fetch</code> + <code>git merge</code></p>
<p>比如我目前在我的 hexo 下操作，我想要与 tommy351的 hexo 保持同步。</p>
<p>首先，<code>git add remote upstream &lt;tommy351的 hexo 地址&gt;</code>    </p>
<p>如果他五分钟前对hexo这个 repo 做了更改，我现在执行<code>git fetch upstream</code> ，并<code>git diff upstream/master</code>就可以看到这些变化。 如果我觉得不错，那么通过<code>git merge upstream/master master</code>就可以把他做的更改合并到我的 hexo 下。</p>
<hr>
<p>okay，到现在为止，在自己 repo 的 master 下的操作，分支操作，与 original的同步和反馈，以及与他人的社交都会了。以后就要尽量多写代码，并用github 管理代码了。</p>
<p>Have fun!</p>
]]></content>
    <category scheme="http://zipperary.com/categories/IT杂谈/" term="IT杂谈"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[吃着火锅唱着歌，博客不停歇]]></title>
    <link href="http://zipperary.com/2014/03/17/writting-on/"/>
    <id>http://zipperary.com/2014/03/17/writting-on/</id>
    <published>2014-03-17T15:26:11.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>昨天跟 Ada 去「3W」coffee 参加「老池老友记」，一个技术交流会，主角是 Mac 君池建强，领衔配角是 Fenng、小道消息冯大辉，绿叶配角有三表和道哥。道哥就是写了《白帽子讲网络安全》的那个道哥，少年班出身，天才，帅哥，口齿伶俐，为人热肠。哦，忘了介绍主角了，不好意思。</p>
<p>池建强以 Mac 君著称，用 Mac 的 IT 从业者几乎不会不知道他吧，他的微信公众号是 Mactalk。插播一句，这几位嘉宾都是自媒体，冯大辉有「小道消息」，三表有「三表龙门阵」，道哥有「道哥黑板报」，各位可斟酌关注。这次交流会的主题是科技与写作，背后涌动的经济因素是老池要在北京签收推销他的这本《人生元编程》。我也是 Mac 用户，从老池那里有过受益，follow 过他的 mac tips。后来发现 google 更好使，就把老池挪做他用了，什么用呢，微信听众。老池给我的感觉是，每一篇文章你都能发现机智的地方，在我眼里是有趣的文章，在我关注的微信公众号中，除了「北大清华讲座」，对老池的关注度是最高的。同样作为一个业余开外的写着，十分欣赏老池的文字，他的这次写作交流会，更不可不参加了。老池在台上讲了讲对于写作的感想，比如为什么写，怎样写。听在我的耳朵里，最后留下的一句呐喊是来自我的内心的：「我要继续写！」。因此，刚泡了脚，吃了柚子，在此畅聊。</p>
<a id="more"></a>

<p>冯大辉嘛，我喜欢他发起的「Startup news」，是 hacker news 的国内版本，山寨（这里不是鞭挞）中的王者，IT 众生在日常阅读中看到什么有益的技术相关文章都可以提交到这里，大家分享好文。我在这个网站受益颇多。他的小道消息微信号，我没怎么看过。他在微博上的犀利我是知道的。对于犀利的人我总是有几分崇敬，不过，茶歇时当我俯视这个偶像时，「群口相声」时他在台上很自然地大笑时，我觉得跟他近了一些。</p>
<p>三表，帅哥（我坐的靠后，朦胧美），自称「脱口秀艺人」，果然名不虚传，大家的笑声和掌声就是佐证。他不是技术人员，好像是写互联网分析的，不是很了解。我喜欢这哥们，有才，幽默，显敦厚。</p>
<p>道哥，看起来比我还瘦，站在一块时比我矮一个头，这不重要。道哥是一个天才，一个网络安全领域的专家，一个奔跑中的创业者（貌似跟创新工场有关），一个女孩子眼中的帅锅，一个说话 balabala 的人，一个和蔼可亲的人，一个跟我合影了的人。</p>
<p>说道合影，来一张全家福吧~</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eej71bvxmtj21kw0w07cz.jpg" alt=""></p>
<p>最近看论文，算法、编程很少顾及，很不应该。搞技术是需要气氛的，我这里安排的前戏就是高密度使用 iTerm、zsh、hotkey以及丢弃 sublime text，重新使用 vim。</p>
<p>另外的一个重要调料就是博客了，耽误不了时间，反而 a lot of fun。刚买了转换线，准备连接大屏显示器和外接键盘，彼时码字更爽了。</p>
<p>控制一下，少浪费点时间。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[重温经典《霸王别姬》]]></title>
    <link href="http://zipperary.com/2014/03/09/ba-wang-bie-ji/"/>
    <id>http://zipperary.com/2014/03/09/ba-wang-bie-ji/</id>
    <published>2014-03-09T08:34:22.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ee9m7fza56j20j80itjv7.jpg" alt=""></p>
<p>许久未看电影了，昨天趁周末把《霸王别姬》再看一遍。</p>
<p>第一次看，似在高中，全班集体看的，我座位偏后，屏幕效果不好，教室也有些噪声，因此很多地方看不清听不清，但大致的故事是看明白了。印象中当时看的很尴尬，因为这部电影中有同性恋的元素，这在当时是没有接触过的。</p>
<p>影片的主人公是张国荣饰演的程蝶衣。作为妓女的孩子，没法养活，母亲只好把他交给梨园戏班，这本是一苦。可小孩子却有十一根手指，这样的形象是等不了舞台的，所以戏班老板不收留他，这又是一苦。母亲无奈，为了让儿子活命，只好狠下心把儿子多余的手指剁下来，如此才得以被收留，但从此几乎成了一个没有母亲的孤儿，苦。这个小孩子叫小豆子。</p>
<a id="more"></a>

<p>在戏班成长的岁月，除了辛苦的练功，主要讲了一点，就是师傅教一出戏，小豆子的台词是「小尼姑年方二八，正青春被师傅削去了头发。我本是女娇娥，又不是男儿郎」。可这个倔强的孩子始终把台词唱成「我本是男儿郎，又不是女娇娥」。在他的眼里，戏和人生是一回事，我是男的，怎么能说成是女的呢。屡教不改。一次被从小照顾自己的师哥小石头亲手惩罚之后，他重新唱出台词，居然唱对了，从此就在自我认知上，把自己定义为「女娇娥」了。他的改变，或许是由于小石头从小保护他，小石头的阳刚，愈发激发他的阴柔，小石头唱《霸王别姬》中的霸王，小豆子便甘愿做霸王的虞姬。</p>
<p>毕业之后，小石头和小豆子分别化名为段小楼和程蝶衣，开戏园，自立门户，做老板。程蝶衣由于在内心的自我认知上已经是女性了，他唱的虞姬已经进入化境，无与伦比。但程蝶衣入戏太深，在戏外仍然像虞姬爱恋霸王一样爱恋自己的师哥，不明白戏是戏，人生是人生，真是「不疯魔不成活」。之后的故事，就是在抗日战争到文革之后这段相当长的历史中，这些人的命运是怎样的随波浮沉的。一方面，程蝶衣还在延续他「不疯魔不成活」的精神，另一方面，我看到的是日本人对艺术的尊重、理解与欣赏，国军的俗劣（虽然不尊重艺术，但抓捕时有逮捕令，执刑前有法庭审理），我党当时的荒唐。尤其是最后一项。那个时代，艺术是犯罪，群众是法官与刽子手，没有任何法治可言，个人被群众的暴政摧残殆尽，为了自保，夫妻反目，亲友成仇，简直荒唐的不能再荒唐了。之前读野夫，读章诒和，这里再次得到印证。老实说，今日还能看到很多当日的影子，我们的国家还很令人担忧。</p>
<p>故事的结局挺悲惨的。段、程的徒弟成了文革中的红卫兵，亲自批斗自己的师傅。段小楼为了自保，揭发妻子菊仙，后者不堪其辱，悬梁自尽。文革后，段小楼与程蝶衣再聚，段唱出那句「我本是男儿郎，又不是女娇娥」，程蝶衣猛然醒来，戏，已经结束，自己再也无法做霸王的虞姬了，活着还有什么意思，拔剑自刎，完成了「霸王别姬」，从一而终，至死仍然是霸王的虞姬。</p>
<p>这部影片有很多值得探讨的，我上面谈到了两点，一是程蝶衣的自我身份认同、同性恋、戏与人生的关系，一是历史和时代对个人命运的玩弄。陈凯歌能在当年拍出这样的电影，很了不起。换在今天，他却拍不出了，因为宣宣比以前更老顽固了。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/电影/" term="电影"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[在 Mac 上安装 Opencv]]></title>
    <link href="http://zipperary.com/2014/03/06/install-opencv-on-mac/"/>
    <id>http://zipperary.com/2014/03/06/install-opencv-on-mac/</id>
    <published>2014-03-06T12:23:12.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>在 Mac 安装 opencv，使用的方案和 linux 是一样的。</p>
<p>先在<a href="http://opencv.org/" target="_blank">官网</a>页面右侧下载<code>OpenCV for Linux/Mac</code>。</p>
<p>打开终端，用<code>tar -xvf opencv压缩文件</code>解压文件。</p>
<p>cd 进入解压后的文件夹。</p>
<p><code>mkdir release</code></p>
<p><code>cd release</code></p>
<p><code>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..</code></p>
<p><code>make</code></p>
<p><code>sudo make install</code></p>
<p>依次执行，最后没报错就是成功了。</p>
<p>我在安装的过程中遇到了一个棘手的问题，大概如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>Linking CXX shared library ../../lib/libopencv_highgui<span class="preprocessor">.dylib</span>
[ <span class="number">35</span>%] Building CXX object modules/video/CMakeFiles/opencv_video<span class="preprocessor">.dir</span>/src/bgfg_gaussmix<span class="preprocessor">.cpp</span><span class="preprocessor">.o</span>
Undefined symbols for architecture x86_64:
  <span class="string">"_ModPlug_GetCurrentOrder"</span>, referenced from:
     _modplug_read_packet <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetCurrentPattern"</span>, referenced from:
     _modplug_read_packet <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetCurrentRow"</span>, referenced from:
     _modplug_read_packet <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetCurrentSpeed"</span>, referenced from:
     _modplug_read_packet <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetCurrentTempo"</span>, referenced from:
     _modplug_read_packet <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetLength"</span>, referenced from:
     _modplug_read_header <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetMessage"</span>, referenced from:
     _modplug_read_header <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
  <span class="string">"_ModPlug_GetName"</span>, referenced from:
     _modplug_read_header <span class="keyword">in</span> libavformat<span class="preprocessor">.a</span>(libmodplug<span class="preprocessor">.o</span>)
</pre></td></tr></table></figure>

<p>各种方法都试了，in vain.最后哥们儿帮我找到了答案：</p>
<p>在 cmake 那步，改成：</p>
<p><code>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. -DWITH_FFMPEG=OFF</code></p>
<p>也就是最后添加了一个参数。什么意思呢？不知道。</p>
<p>参考：</p>
<ol>
<li><a href="http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation" target="_blank">Installation in Linux — OpenCV 2.4.8.0 documentation</a></li>
<li><a href="http://stackoverflow.com/questions/14517406/opencv-make-error" target="_blank">c++ - openCV make error - Stack Overflow</a></li>
</ol>
]]></content>
    <category scheme="http://zipperary.com/categories/IT杂谈/" term="IT杂谈"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[《往事並不如煙》：深入那段歷史]]></title>
    <link href="http://zipperary.com/2014/02/28/wang-shi-bing-bu-ru-yan/"/>
    <id>http://zipperary.com/2014/02/28/wang-shi-bing-bu-ru-yan/</id>
    <published>2014-02-28T13:11:49.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>這本書讀的是繁體本，應該是台灣版本，大陸本刪節出版後即遭禁，港版由牛津大學出版社出版，但仍然有部分刪節，只有臺版是最完整的。看繁體中文的書對我來說很有挑戰性，之前勉強讀完了汪曾祺的《受戒》，由於比較短，看起來略輕松，這次卻苦煞了我，一是對繁體還未適應，因而讀起來很慢，二是有許許多多不認得的字，比如「憂鬱」的「鬱」，又如「彙報」的「彙」，每遇到這種情況，只能停下來猜測，或者拍照發給 Aka 求援，或者用手機繁體輸入法打出幾個可能的詞來驗證，總之是很慢。然而看到後面，速度已經提高了不少，雖然仍不及簡體之一目瞭然，然也能一目數字了。對於繁體書，現在忽然感覺某些深沈有味道的文字，只有繁體才能傳達出來。另外，許多優秀的作品在國內還是不得發表，不得不轉而尋覓並閱讀台灣的版本了，比如 Kindle 裏還存著未讀的繁體本《國史大綱》。</p>
<p>上面簡單敘述了一下我閱讀繁體書的體驗，接下來聊一聊這本書。</p>
<p>作者是章詒和，其父為章伯鈞。章伯鈞是誰？是民盟的創辦者之一，建國後任交通部長，整風、反右、文革中被毛主席欽點為中國最大的反派頭子，直到今天仍然未予改正。民盟本身就是藏龍臥虎、高級知識分子聚集的地方，章伯鈞經歷非凡，在近代中國歷史上扮演了很重要的角色，其交往之人也自非凡夫俗子，大多是在今天仍然非常響亮的名字。在反右開始時，章詒和作為女兒，已經在上中學，智力學識都不再是不懂事的小孩子了，父母及那個圈子裏發生的事情，章詒和不僅感興趣，很關注，父母也會對她講，父母的朋友們都是高級知識分子，很有修養，也會對她講一些事情。作者親身經歷過那個年代，並做過淺層的參與者與深度的觀察者，用自己的回憶來書寫下那段波瀾壯闊的歷史。</p>
<a id="more"></a>

<p>書中講到的時期主要是五十年代到七十年代，期間有整風、反右、饑荒、文革這些事情。書中分別作文講述了史良、储安平、张伯驹、聂绀弩、康同璧、罗隆基這些與章家交往甚深的人。「张伯驹」我沒聽過，索性沒看。其餘的人，除了康有為的女兒康同璧外，都被打為右派，經歷悲慘。</p>
<p>史良是個優雅和講究的女士，是民盟的負責任之一，起初與章家交往很好，之後由於自危，在反右運動中攻擊章伯鈞，這個多少年來的摯友，由於親共，被提拔。</p>
<p>儲安平就很有名了，民國時期他的《觀察》雜誌就蜚聲全國，建國後，章伯鈞邀他做《光明日報》的主編，毛主席興起整風鳴放後，這個懷抱新聞理想的自由民主鬥士積極給共產黨提意見，缺少政治敏感性的他，更是拋出了「當天下」之說，雖然全國有識之士積極響應，但在共產黨那裏埋下了壞印象，之後被批鬥、戴帽子、劃右派，最後失蹤，章伯鈞堅持認為儲安平是自殺了。</p>
<p>聂绀弩是個有才華真性情的作家，敢怒敢言，言語冒犯了毛澤東和共產黨，被劃為右派，判處無期徒刑，關緊大牢。經過章伯鈞的妻子李建生和朱靜芳的全力營救，聂绀弩最終冒名頂替了一個國民黨戰犯被特赦出獄。之後便和李建生、朱靜芳等成為至交。出獄後發現女兒已經自殺，妻子已經劈腿，自己沒有工資只能依靠妻子養活，這對他的自尊和精神是怎樣的摧殘。然而經歷過人生的最苦之後，晚年的聂绀弩在文學上成就斐然。</p>
<p>康同璧是康有為的女兒，康同璧及女兒羅儀風，被作者成為「最後的貴族」。是的，無論是生活、交往、性情、禮儀，他們當之無愧。作者尤其感激的是，在那樣一個政治緊張的年代，人人自危，康同璧卻非常欣賞章伯鈞等右派，並以結交這樣的朋友為榮。康同璧去章家參加聚會，在自家請右派的人會面，文革時收留身處危險境地的作者在家居住，無論是智慧、膽量，還是善良、高貴，讓人敬佩又感動。然而在那樣一個荒唐的年代，康死後葬禮簡單的令人髮指，其女最後也極其落魄，未得善終，令人不勝唏噓。</p>
<p>罗隆基是個「大牛」，清華讀書時就風光無限，之後去英美留學，在美國拿到政治學博士學位，回來後在清華北大西南聯大等任教，後來辦刊物，創辦民盟，無不令人矚目，其弟子也大多成就不小。他博聞強識，在法律方面是個活字典和專家，在政治上提倡英美式的民主。由於民盟天生的派系原因，他和章伯鈞一直不和，但並不是私人恩怨，都是工作之事。罗隆基不懂得為政需要秉持中庸之道，他也敢怒敢言，又氣量狹小，因而人緣不好。反右運動中，他被狂轟濫炸式地批鬥，最後屈打成招。反右時，他與章伯鈞被荒唐地成為「章羅聯盟」，定性是反黨反人民反共產主義的。劃為右派後，人人見而遠之，章羅這兩個被孤立的孤家寡人，沒想到最終卻成了好友，真的成了「聯盟」。羅最後死於心臟病。</p>
<p>章詒和在這本書中，不僅寫政治，也寫生活，並努力梳理很多事情的來龍去脈。寫政治、反右、文革，必然要提到這些右派分子的言論，我看到後拍案叫絕，他們講的是好的是對的，卻在荒唐的年代因言獲罪。文中也談了許多關於反右、文革為何發起，毛澤東究竟打的什麼算盤。還講了這個時代的共產黨是怎麽樣的，右派是怎麽樣被殘酷迫害的，等等。寫生活，聚會，聊天，談戀愛，每個人生活中的一面，每個人的性格，等等。</p>
<p>作者的文筆不華麗，很沈穩，其文風正適合這樣的主題，獨來讓人又是嗟嘆、又是感動。很感謝有這麽一本書，讓我看到了許多未曾看到的故事，知道了許多未曾瞭解的情況。今天看「噴嚏圖掛」，我笑了，我看到了書中那個年代的痕跡，還很明顯。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/读书笔记/" term="读书笔记"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[数据结构与算法笔记：三（大结局）]]></title>
    <link href="http://zipperary.com/2014/02/23/dsv-notes-3/"/>
    <id>http://zipperary.com/2014/02/23/dsv-notes-3/</id>
    <published>2014-02-23T02:37:01.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://zipperary.com/2014/01/04/dsv-notes/">数据结构与算法笔记：一 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/01/06/dsv-notes-2/">数据结构与算法笔记：二 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/02/23/dsv-notes-3/">数据结构与算法笔记：三（大结局） | Zippera’s blog</a></p>
<hr>
<h1 id="Heap-like_Data_Structures">Heap-like Data Structures</h1>
<ul>
<li><p>Heaps：小顶堆（二叉树，完全树），每个节点都比它的左右子树小。按照层级从左到右插入节点，然后自下向上调整大小。删除最小值的时候，直接删除根节点（一直是最小的），然后把最后一个节点移到根节点，然后自顶向下调整大小。若给出一个已经建立好的完全树，想调整为堆，则需要自底向上、从右到左地逐层调整，调整时还需要考虑子树是否不再满足堆条件，if so，自顶向下调整。由于堆是一个按照层次编号的完全树，所以用一个数组作为数据结构。操作堆就是操作数组。</p>
</li>
<li><p>Binomial Queues：二项队列，也叫Binomial heap，是一种形状很有特点的树。首先要知道什么是二项树：如图为四个不同的二项树，其规律为：度数为k的二项树有一个根结点，根结点下有k个子女，每个子女分别是度数分别为k-1,k-2,…,2,1,0的二项树的根。度数为k的二项树共有2^{k}个结点，高度为k。在深度d处有<code>{\tbinom  nd}</code>（二项式系数）个结点。二项堆自然就是满足节点相对大小关系的二项树。二项堆的插入很简单，只需要新建一个节点，并合并。合并的对象只能是两个度相同的二项堆：比较二个根结点关键字的大小，其中含小关键字的结点成为结果树的根结点，另一棵树则变成结果树的子树。删除最小的节点就是删除根节点，根节点下的几个子树全部分开。二项堆在各类操作中时间复杂度都为O(logn)，可以说性能很好。其存储结构一般为链表。</p>
</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1edr9eqj7s2j20k009xgmb.jpg" alt=""></p>
<a id="more"></a>

<ul>
<li>Fibonacci Heaps：如图，斐波那契堆由这样一些小顶堆组成，其中每个节点ADT 如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">struct</span> FibonacciHeapNode {
       <span class="keyword">int</span> key;       <span class="comment">//结点</span>
       <span class="keyword">int</span> degree;    <span class="comment">//度</span>
       FibonacciHeapNode * left;  <span class="comment">//左兄弟</span>
       FibonacciHeapNode * right; <span class="comment">//右兄弟</span>
       FibonacciHeapNode * parent; <span class="comment">//父结点</span>
       FibonacciHeapNode * child;  <span class="comment">//第一个孩子结点</span>
       <span class="keyword">bool</span> marked;           <span class="comment">//是否被删除第1个孩子</span>
   };
</pre></td></tr></table></figure>

<p>并且用min 指向最小的根节点。每个节点有一个指针指向其一个子女，它的所有子女由双向循环链表连接，不同的小顶堆的根节点也是通过这种链表连接，叫做根表。</p>
<p>插入新元素时，只要将其作为单元素 F 堆，并跟原有堆合并，合并的方式是新 F 堆加入原 F 堆的根表中。</p>
<p>删除元素时，先把 min 指向的最小节点删除，然后将剩下的小顶堆分开，并按照二项堆组合的方式重新组合。</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eduqnjhkqdj20du06074l.jpg" alt=""></p>
<ul>
<li>Leftist Heaps：左偏堆，每个节点除了有左右孩子和键值外，还有一个距离。什么是距离呢？ 引用维基百科的话：「当且仅当节点 i 的左子树且右子树为空时，节点被称作外节点（实际上保存在二叉树中的节点都是内节点，外节点是逻辑上存在而无需保存。把一颗二叉树补上全部的外节点，则称为extended binary tree）。节点 i 的距离是节点 i 到它的后代中的最近的外节点所经过的边数。特别的,如果节点 i 本身是外节点,则它的距离为 0;而空节点的距离规定为-1 。」如图。除了堆的性质外，还有一条「节点的左子节点的距离不小于右子节点的距离。」其插入删除等基本操作都是基于合并。怎样合并呢？找到 root 键值最小的那个，用其右子树与其他树合并，若右子树为空，把另外的树直接弄过来，若此时右子树距离比左子树大了，那就交换左右子树；若右子树不空，把右子树摘下来与其他树合并，如此递归进行。删除堆中最小值时，先删除它，再把遗留的几个子树按照前述方法合并。左偏堆合并操作的平摊时间复杂度为O(log n)。</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1edrakap9umj206203pweg.jpg" alt=""></p>
<ul>
<li>Skew Heaps：斜堆，上述左偏堆就是一种特殊的斜堆。斜堆没有距离的概念，其合并过程与左偏堆几乎一样，只是在每次合并之后都要左右子树互换一下（启发规则）。这样往往能导致最后形成的树中左子树比右子树深，所以是斜的。</li>
</ul>
<h1 id="Graph_Algorithms">Graph Algorithms</h1>
<ul>
<li>Breadth-First Search：广度优先搜索。图可分为有向图和无向图（都可应用本算法），其表示形式有图形、邻接表、临界矩阵，注意图中 Parent 和 Visited 两个数组。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eds3ts9pxkj21140i476d.jpg" alt=""></p>
<ul>
<li><p>Depth-First Search：深度优先搜索，基本同上，除了搜索的顺序不同。搜索过程中会涉及到回溯问题，而回溯可以用栈这种数据结构，也可以用递归的这种运行形式。广度优先搜索则不会有回溯的情况。</p>
</li>
<li><p>Connected Components：连通分量，对于无向图，就是这样的一个子图：任意两个节点都可以路径可达，再加入该子图之外的节点后就不满足任意可达性了，所以也可以叫做最大连通子图。其实每个独立的无向图都是连通分量。还有一个叫强联通分量，是对应于有向图的，这时就不太容易寻找一个有向图的强连通分量了，因为要保证任意两个节点是互相可达的。Kosaraju算法、Tarjan算法、Gabow算法是目前比较有效的算法。DSV 中用的哪种，我还没看明白，等看完《算法概论》中介绍的那种再说。</p>
</li>
</ul>
<ul>
<li>Dijkstra’s Shortest Path：用于求解带权有向图（也可求无向图）的单源最短路径。如图，我们用这样一个表格来演示并记录。Vertex 表示图中的节点；Known 表示运行到目前为止，是否确定了该节点的最终最短路径，初始为 F（否）；Cost 表示目前为止从源节点到该节点的最短路径，初始为 INF（无穷大）； Path 是源点经过哪个节点到达的这个节点，初始为-1（无）。算法运行的过程：假设源点为2，此时2为 T，寻找2的直接邻节点，并更新 Cost（如果新 cost 比当前的小就更新，否则不更新），同时更新 Path 为2；然后，在所有F 的节点中，选择当前 Cost 最大的一个，标记为 T，这个节点的全局最短路径就确定下来了，以此作为中间节点，寻找其直接邻节点，并更新 Cost（注意，已经为 T 的不再更新）和 Path；如此循环，直到所有节点都为 T。</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eds5aom0dij20tq0dsq3w.jpg" alt=""></p>
<p>最终得到如下图所示的表格。接下来就是把 Path 表示出来。比如运行到7的时候，7的 path 是5，5的是6，6的是2，所以7的最终 path 是 2 6 5 7.</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eds6kkf9paj20an07iaa9.jpg" alt=""></p>
<ul>
<li><p>Prim’s Minimum Cost Spanning Tree：Prim 算法，对于给定的无向图，找出最小生成树。最小生成树就是包含图中所有节点和部分边是一个树，并且其权值之和最小。该算法的运行过程就是从源节点出发，选择权值最小的邻近节点，再以此为当前节点，选择未访问的权值最小的邻近节点，如此循环，若到头了，则回溯。总体来说是大 DFS 中包含着小 BFS。具体的运行过程可以使用Dijkstra算法中使用的表格形式。</p>
</li>
<li><p>Topological Sort (Using Indegree array)：对于一个DAG，一定存在拓扑排序，使得对于 uv,在拓扑排序中，u 一定在 v 前面。这里使用直观的Kahn算法：有两个集合，L 表示已经排好的，S 表示入度为0的节点；每次从 S 中取出一个节点 n 放入 L 中，并查看从 n 出发的节点中是否有入度减为0的，若有，加入到 S 中，然后再从 S 中取节点，循环。。。如果最后剩下边，说明该图是有环的，不存在拓扑序列，否则最后得到的 L 即拓扑序列。从算法的执行过程来看，它是基于队列的。</p>
</li>
<li><p>Topological Sort (Using DFS)：基于 DFS 的拓扑排序，这里 S 是所有<strong>出度</strong>为0的节点的集合。对于每个节点，递归访问以它为尾的所有节点，并标记为 Visited，并按照递归的退出顺序把节点加入到 L 中。这种方法其实也很直观，出度为0的节点，回溯到头一般就是入度为0的节点了。深度优先遍历会用到递归或栈。</p>
</li>
<li><p>Floyd-Warshall (all pairs shortest paths)：留着，太复杂了。</p>
</li>
<li><p>Kruskal Minimum Cost Spanning Tree Algorithm：Kruskal 算法，对于给定的无向图，找出最小生成树。其方法很简单，就是从所有边中，依次挑选最小的边形成树的一个边，加入到当前的树中，如果这个边使树成为图，就舍弃，寻找次最小的，直到所有的节点都进入这个树中。</p>
</li>
</ul>
<h1 id="Dynamic_Programming">Dynamic Programming</h1>
<p>Calculating nth Fibonacci number，<br>Making Change，<br>Longest Common Subsequence：动态规划适用于有最优子结构和重叠子问题的问题。最优子结构是指局部最优解能决定全局最优解，这样我们才能把问题分解成子问题来解决。子问题重叠性质是指「在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。<br>」最常用的例子是斐波那契数列。其求解最常用的算法是如下递归：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">fib</span><span class="params">(n)</span></span>
       <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">or</span> n = <span class="number">1</span>
           <span class="keyword">return</span> <span class="number">1</span>
       <span class="keyword">return</span> fib(n − <span class="number">1</span>) + fib(n − <span class="number">2</span>)
</pre></td></tr></table></figure>

<p>虽然通过递归把问题分解为子问题了，但是，递归过程中很多子问题被重叠计算了，比如当n=5时，fib(5)的计算过程如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function">fib(<span class="number">5</span>)</span>
<span class="function">fib(<span class="number">4</span>)</span> + <span class="function">fib(<span class="number">3</span>)</span>
(<span class="function">fib(<span class="number">3</span>)</span> + <span class="function">fib(<span class="number">2</span>)</span>) + (<span class="function">fib(<span class="number">2</span>)</span> + <span class="function">fib(<span class="number">1</span>)</span>)
((<span class="function">fib(<span class="number">2</span>)</span> + <span class="function">fib(<span class="number">1</span>)</span>) + (<span class="function">fib(<span class="number">1</span>)</span> + <span class="function">fib(<span class="number">0</span>)</span>)) + ((<span class="function">fib(<span class="number">1</span>)</span> + <span class="function">fib(<span class="number">0</span>)</span>) + <span class="function">fib(<span class="number">1</span>)</span>)
(((<span class="function">fib(<span class="number">1</span>)</span> + <span class="function">fib(<span class="number">0</span>)</span>) + <span class="function">fib(<span class="number">1</span>)</span>) + (<span class="function">fib(<span class="number">1</span>)</span> + <span class="function">fib(<span class="number">0</span>)</span>)) + ((<span class="function">fib(<span class="number">1</span>)</span> + <span class="function">fib(<span class="number">0</span>)</span>) + <span class="function">fib(<span class="number">1</span>)</span>)
</pre></td></tr></table></figure>

<p>改进的方法是，我们可以通过保存已经算出的子问题的解来避免重复计算：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">array</span> map [<span class="number">0.</span>..n] = { <span class="number">0</span> =&gt; <span class="number">0</span>, <span class="number">1</span> =&gt; <span class="number">1</span> }
fib( n )
    <span class="keyword">if</span> ( map m does not contain key n)
        m[n] := fib(n − <span class="number">1</span>) + fib(n − <span class="number">2</span>)
    <span class="keyword">return</span> m[n]
</pre></td></tr></table></figure>

<h1 id="其他">其他</h1>
<ul>
<li>Disjoint Sets：并查集，也叫union-find algorithm，因为该数据结构上的主要操作是 find 和 union，还有一个基本的 makeset 操作。</li>
</ul>
<p>数据结构是一个树，每个节点除了有值外，还有一个指针指向父节点。一个树就是一个集合，树的根节点代表这个集合。由于只需要一个指针指向父节点，一般用一个数组表示这棵树。</p>
<p>数据结构说清楚了，接下来谈谈其操作。makeset 的作用是建立一个只含X 的集合。find 的作用是找到 X 的根节点，即找到 X 属于哪个集合。union 的作用是把 x 和 y 代表的集合合并。这三个操作的代码非常简单，但是得到的树会很高很偏，在之后的操作中效率就低了。对此有两种优化方法：路径压缩和按秩合并。下面给出最终代码，在注释处注明其改进：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre>
<span class="keyword">int</span> father[MAX];<span class="comment">//用数组表示树，记录每个节点的父节点索引</span>
<span class="keyword">int</span> rank[MAX];<span class="comment">//</span>

<span class="comment">/* 初始化集合*/</span>
<span class="keyword">void</span> Make_Set(<span class="keyword">int</span> x)
{
    father[x] = x; <span class="comment">//只有一个元素的集合，父节点是自身，也可指定其他，如-1.</span>
    rank[x] = <span class="number">0</span>;   <span class="comment">//只有一个节点，秩（深度）为0</span>
}

<span class="comment">/* 查找x元素所在的集合,回溯时压缩路径*/</span>
<span class="keyword">int</span> Find_Set(<span class="keyword">int</span> x)
{
    <span class="keyword">if</span> (x != father[x])
        {
            father[x] = Find_Set(father[x]); <span class="comment">//回溯时把中间经过的节点的父节点都指向根节点，使树扁平化，压缩路径</span>
        }
    <span class="keyword">return</span> father[x];
}

<span class="comment">/* 按秩合并x,y所在的集合 */</span>
<span class="keyword">void</span> Union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)
{
    x = Find_Set(x);
    y = Find_Set(y);
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;<span class="comment">//在一个集合中，不用合并</span>
    <span class="keyword">if</span> (rank[x] &gt; rank[y])
        {
            father[y] = x;<span class="comment">//总是把秩小的树的根节点指向较大的树的根节点，这样秩不会增加</span>
        }
    <span class="keyword">else</span>
        {
            <span class="keyword">if</span> (rank[x] == rank[y])
                {
                    rank[y]++;
                }
            father[x] = y;
        }
}
</pre></td></tr></table></figure>

<p>参考《<a href="http://www.cnblogs.com/cherish_yimi/archive/2009/10/11/1580839.html" target="_blank">并查集—学习详解</a>》和《<a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank">并查集 - 维基百科，自由的百科全书</a>》。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/机器学习/" term="机器学习"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[常用采样方法]]></title>
    <link href="http://zipperary.com/2014/02/22/sampling-methods/"/>
    <id>http://zipperary.com/2014/02/22/sampling-methods/</id>
    <published>2014-02-22T11:27:25.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习 MCMC，一种特殊的采样方法，顺便把其他常用的方法了解了一下。</p>
<h3 id="为什么要采样？">为什么要采样？</h3>
<p>很多问题，我们只需要使用数学解析的方法即可解决。例如对 f(x)做积分，如果 <code>f(x) = x^2</code>，那么直接积分就行，很简单。</p>
<p>若f(x)是标准正态分布的概率密度函数（pdf），求[a,b]之间的定积分，那么直接用数学解析方法就搞不定了，因为我们知道正态分布的积分是不可求的。既然无法用解析方法计算精确值，那么退而求其次，不妨寻找一种可以求得近似值的方法。例如：</p>
<p><code>f(x) = f(x) * g(x) * 1/g(x) = g(x) * (f(x) * 1/g(x))</code>。这里我们找到一个容易采样的 pdf g(x)，并对其采样得到{X1…Xn}。连续函数的积分就可以转化为离散值的求和。这被称为蒙特卡洛积分。</p>
<p>从上面例子可以看到，采样方法可以对诸如积分这种无法用解析方法求解的方法进行近似求解。接下来就是问题的核心：怎样采样？</p>
<h3 id="简单采样方法">简单采样方法</h3>
<p>最简单的抽样是均匀采样，也就是均匀产生[0,1]之间的随机数，编程语言中一般使用 rand()函数。之所以说是均匀采样，是因为这些样本服从均匀分布。随机数的产生，在计算机中一般通过线性同余的方法实现。</p>
<p>另外，一些简单的分布，如正态分布，也可以在均匀采样的基础上实现采样。</p>
<p>对于其他函数我们就无能为力了，只能通过一些高级点的方式进行采样。</p>
<h3 id="接受-拒绝采样">接受-拒绝采样</h3>
<p>我们需要对一个分布π(x)进行采样，但是却很难直接进行采样，所以我们想通过另外一个容易采样的分布q(x)的样本，用某种机制去除掉一些样本，从而使得剩下的样本就是来自与所求分布f(x)的样本。</p>
<p>条件：</p>
<ul>
<li>对q(x)采样比较容易</li>
<li>q(x)的轮廓接近π(x)，且有 π(x)≤Mq(x),∀x</li>
</ul>
<p>过程：</p>
<ul>
<li>产生样本X~q(x)，和U~Uniform[0,1]</li>
<li>Y=U*Mq(x)，若Y≤π(X)，则接受X，否则拒绝。</li>
</ul>
<p>解释：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1edq3b3al1ij207z061wek.jpg" alt=""></p>
<ul>
<li>根据 q(x)采样 X，得到 Mq(X)，在[0,1]之间产生随机数U，也就是在[0,Mq(X)]产生随机数Y=U*Mq(x)。如果Y 在π(x)曲线下方，那么就选择接受，否则拒绝。为什么呢？在上图两个曲线相隔越远的地方，随机Y在π(x)下方的概率越小，即接受这个采样X的概率越小。这是合理的，这时候两个曲线间隔远， Mq(x)的采样X不能直接用于π(X)。反之，如果两个曲线相隔近，那么U越可能在π(X)下方，越可能接受这个采样，既然曲线相隔近，那么对Mq(x)的采样就可以近似对π(X)的采样了嘛！</li>
</ul>
<p>但是拒绝采样效率会比较低，因为有很多采样都拒绝了嘛！</p>
<h3 id="重要性采样">重要性采样</h3>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1edq3njein6j20ab052dft.jpg" alt=""></p>
<p>如图，如果我们想求积分，也就是面积，且 f(x)不能求积分形式，一种方法就是在[a,b]间<strong>均匀</strong>采样N 个点，并用 f(Xi)乘以(b-a)/N 即宽度，累加求和就能得到近似的积分值。这里我们用的权重是相同的：(b-a)/N，就是说每个小矩形的宽度都是相等的。</p>
<p>但很多时候，曲线比较高的地方需要多采样并精确刻画，曲线低的地方可以少采样，这样能减小最后结果与真实值之间的误差。如下图：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1edq3v5oc42j20aj05iaa3.jpg" alt=""></p>
<p>我们采用与 f(x)类似的 g(x)来采样，g(x)如图中右上角所示。此时宽度怎么确定呢？宽度就是1/g(Xi)，这就能体现出不同点的权重不同了。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1edq40yum9vj205w00w743.jpg" alt=""></p>
<h3 id="MCMC采样">MCMC采样</h3>
<p>上述都是独立性采样，采样的效率还不高。MCMC 是一种关联采样，当前采样有赖于前一个采样结果。MCMC 的全程是马尔可夫蒙特卡罗。马尔可夫，是说前后两个采样结果的关联性。蒙特卡罗是一种随机模拟方法，用采样的方法解决解析问题，如前面提到的蒙特卡洛积分。</p>
<p>若想对π(x)进行采样，首先构建一个马尔可夫链，该马尔可夫链的状态转移矩阵满足特定条件时，会存在一个稳定状态，稳定分布就是π(x)。根据某定律，我们从某个状态出发，在马尔可夫链每步得到的分布中采样，得到 M 个样本，这些样本就近似服从π(x)。要想构建符合条件的状态转移矩阵并抽样，有两种方法：Metropolis-Hastings 算法和Gibbs Sampling方法。具体介绍可参考文末给出的链接。</p>
<p>参考：</p>
<p><a href="http://www.wuhaijia.com/wordpress/%E6%8E%A5%E5%8F%97-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7%EF%BC%88acceptance-rejection-sampling%EF%BC%89/" target="_blank">http://www.wuhaijia.com/wordpress/%E6%8E%A5%E5%8F%97-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7%EF%BC%88acceptance-rejection-sampling%EF%BC%89/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4e5740460100cw5b.html" target="_blank">http://blog.sina.com.cn/s/blog_4e5740460100cw5b.html</a></p>
<p><a href="http://www.52nlp.cn/lda-math-mcmc-%E5%92%8C-gibbs-sampling2" target="_blank">http://www.52nlp.cn/lda-math-mcmc-%E5%92%8C-gibbs-sampling2</a></p>
]]></content>
    <category scheme="http://zipperary.com/categories/机器学习/" term="机器学习"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[转身前行]]></title>
    <link href="http://zipperary.com/2014/02/20/moveon/"/>
    <id>http://zipperary.com/2014/02/20/moveon/</id>
    <published>2014-02-20T08:56:34.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>昨天下午、晚上打过羽毛球，久不锻炼，乍一运动，身体便吃不消，一觉醒来，脖子、右臂、屁股都疼得厉害，右臂更是酸软无力。即便这样，我仍然感到不得不回归到我的博客了，上一篇是写于8号，12天之前。</p>
<p>我并未因博客没有按期维护而自责，原本就没打算像去年一样坚持两天一篇的频率，我之不得不回归，是因为最近的学习生活有些乱糟糟，需要用某项习惯来维持并支撑整体的稳定规整。</p>
<a id="more"></a>

<p>12号便提前回校，这几天可谓无忧无虑，完全 free time，没有人管，没有任务，我却没有做到自主自强，趁此机会恶补般地学习，而是放任自由，听从自己的惰性。首先是极不理智地开始看《纸牌屋》的第一季第一集，初衷是了解一下这部美剧为什么有这么大的流传度，结果证明我是作茧自缚，一旦开始便很难刹住，浪费大把的时间把第一季给搞定了。刚刚把第二季第一集看完，侥幸回归理智，来到这里自省。除了纸牌屋，还看了《雷神》两部，其余的时间或是浪费在毫无目的的上网浏览，或是效率低下的学习（《数字图像处理》和《数字信号处理》），甚至还组队玩QQ麻将，幸好运气不佳接连输子，搞得我也没兴趣玩了。总之，这几天消磨时间，把开学前对自己的期许忘的一塌糊涂，实在罪过！</p>
<p>心里装着很多东西，有需要记住的 past，有需要开创的 future，怎么能继续放纵自己的惰性，任无情前行的时间把我甩下几条街呢！好吧，我也要转身前行了！</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[偷得浮生半月闲]]></title>
    <link href="http://zipperary.com/2014/02/08/winter-vacation/"/>
    <id>http://zipperary.com/2014/02/08/winter-vacation/</id>
    <published>2014-02-08T03:03:00.000Z</published>
    <updated>2014-05-12T11:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>好几天没有更新博客了，从这一个侧面也可以看出我寒假的状态是怎么样的。像往年一样，假期之前满心期待地列了几条待做事项，根据往年的教训，并未真的打算都一一完成，只想在无聊到想要学习的时候以备参考。现在假期几尽，稍作回顾，发现只在假期开始的几天偶尔学了一些，之后便一蹶不振，无聊至极的时候也不至于无聊到学习了。</p>
<p>那么这些天做了什么呢？</p>
<ul>
<li>影视作品。没事、无聊的时间全部被影视剧填充了，甚至还占用了不少大块、完整的上好时间。《神探夏洛克》第二三季，《康熙王朝》全50集，《刀锋战士》第二三部，《陆小凤传奇》六部，《尼基塔》最后一季。</li>
<li>阅读。《鹿鼎记》最后十回，《万历十五年》，《受戒》，《胡适口述自传》，《乡关何处》，还有一些推送过来的文章。</li>
<li>打麻将，两天。</li>
<li>陪小外甥女。</li>
</ul>
<p>基本上来说，有别人的时候没法学习，一个人的时候不愿学习，总归是不学习。</p>
<p>昨天看知乎「北上广深」那个帖子，看到知友们辛苦奋斗，反观自己的偷闲，深深自责。「偷闲」实在该转为「偷学」了。</p>
]]></content>
    <category scheme="http://zipperary.com/categories/生活/" term="生活"/>
  </entry>
</feed>
